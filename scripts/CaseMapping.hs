{-# LANGUAGE OverloadedStrings #-}

module CaseMapping where

import Foundation
import Foundation.IO 
import Foundation.String
import Foundation.Collection (mapM_)
import qualified Foundation.Parser as P
import GHC.Base (String(..))

import CaseFolding
import Debug.Trace

main = do
--  psc <- parseSC "SpecialCasing.txt"
  pcf <- parseCF "CaseFolding.txt"
--scs <- case psc of
--         Left err -> print err >> return undefined
--         Right ms -> return ms
  (r,cfs) <- case pcf of
           P.ParseOk r ms -> return (r,ms)
           P.ParseFailed err -> putStrLn (show err) >> undefined
           _ -> undefined
  h <- openFile ("./CaseMappingGenerated.hs") WriteMode
  let comments = ("--" <>) <$>
                 take 2 (cfComments cfs)-- <> take 2 (scComments scs)
  (hPut h) . toBytes UTF8  . intercalate "\n" $
                      ["{-# LANGUAGE Rank2Types #-}"
                      ,"-- AUTOMATICALLY GENERATED - DO NOT EDIT"
                      ,"-- Generated by scripts/CaseMapping.hs"] 
                      <> comments <>
                      [""
                      ,"module Data.Text.Internal.Fusion.CaseMapping where"
                      ,"import Data.Char"
                      ,"import Data.Text.Internal.Fusion.Types"
                      ,""]
--mapM_ (hPutStrLn h) (mapSC "upper" upper toUpper scs)
--mapM_ (hPutStrLn h) (mapSC "lower" lower toLower scs)
--mapM_ (hPutStrLn h) (mapSC "title" title toTitle scs)
  (hPut h) . toBytes UTF8 . intercalate "\n" $ mapCF cfs
  (hPut h) . toBytes UTF8  . intercalate "\n" $
                      ["Remainer: "]
                      <> [r] 
  closeFile h
